{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { Dispatch, SetStateAction, useLayoutEffect, useRef, useState } from 'react';\n\n/**\n * `useState` that updates based on changes to provided value. If `value`\n * changes, the `state` value returned by `useUpdatableState` will reflect the\n * new value.\n * @param value The external value that initially populates `state` and from\n *        where `state` receives updates.\n * @param predicate An optional function (`(value, previous): boolean`) to\n *        compare the current and previous `value` properties. If it returns\n *        `false`, `state` will be updated and `changed` will be `true` until\n *        the component is rendered. If not provided, the new and previous\n *        values will be compared by a strict identity comparison (`===`).\n * @returns `[state, setState, changed]` where `state` and `setState` behave\n *          exactly like with the `useState` hook, including guarantees that\n *          `setState` will not change. `change` will be `true` when `value`\n *          changes between renders.\n */\nfunction useUpdatableState<T>(value: T, predicate: StateComparator<T> = defaultComparator): UpdatableResult<T> {\n  // I am explicitly choosing to modify the array returned by useState instead\n  // of spreading its contents into a new array, in case React makes any\n  // guarantees about the array's identity.\n  const stateArray: UpdatableResult<T> = useState(value) as any;\n  const [previousValue, setPreviousValue] = useState<T>(value);\n  const changedRef = useRef(true);\n\n  if (!predicate(value, previousValue)) {\n    changedRef.current = true;\n    stateArray[1](value);\n    setPreviousValue(value);\n  }\n  stateArray[2] = changedRef.current;\n\n  useLayoutEffect(() => {\n    changedRef.current = false;\n  });\n\n  return stateArray;\n}\n\nexport default useUpdatableState;\n\nconst defaultComparator = <T>(a: T, b: T) => a === b;\n\ninterface StateComparator<T> {\n  (a: T | undefined, b: T | undefined): boolean;\n}\n\ntype UpdatableResult<T> = [T, Dispatch<SetStateAction<T>>, boolean];\n"],"names":["useState","useRef","useLayoutEffect"],"mappings":";;;;AAEA;;;;;;;;;;;;;;;;AAgBA,SAAS,iBAAiB,CAAI,KAAQ,EAAE,SAAiD;IAAjD,0BAAA,EAAA,6BAAiD;;;;IAIvF,IAAM,UAAU,GAAuBA,cAAQ,CAAC,KAAK,CAAQ,CAAC;IACxD,IAAA,KAAoCA,cAAQ,CAAI,KAAK,CAAC,EAArD,aAAa,QAAA,EAAE,gBAAgB,QAAsB,CAAC;IAC7D,IAAM,UAAU,GAAGC,YAAM,CAAC,IAAI,CAAC,CAAC;IAEhC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,aAAa,CAAC,EAAE;QACpC,UAAU,CAAC,OAAO,GAAG,IAAI,CAAC;QAC1B,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QACrB,gBAAgB,CAAC,KAAK,CAAC,CAAC;KACzB;IACD,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC;IAEnCC,qBAAe,CAAC;QACd,UAAU,CAAC,OAAO,GAAG,KAAK,CAAC;KAC5B,CAAC,CAAC;IAEH,OAAO,UAAU,CAAC;AACpB,CAAC;AAID,IAAM,iBAAiB,GAAG,UAAI,CAAI,EAAE,CAAI,IAAK,OAAA,CAAC,KAAK,CAAC,GAAA;;;;"}
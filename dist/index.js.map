{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { Dispatch, SetStateAction, useState } from 'react';\n\n/**\n * `useState` that updates based on changes to provided value. If `value`\n * changes, the `state` value returned by `useUpdatableState` will reflect the\n * new value. A third array element, `changed`, will be set to `true` for the\n * render cycle that caused the change, as a snapshot indicator that a change\n * took place. Future render cycles will not retain this `true` value.\n * @param value The external value that initially populates `state` and from\n *        where `state` receives updates.\n * @param predicate An optional function (`(value, previous): boolean`) to\n *        compare the current and previous `value` properties. If it returns\n *        `false`, `state` will be updated and `changed` will be `true` until\n *        the component is rendered. If not provided, the new and previous\n *        values will be compared by a strict identity comparison (`===`).\n * @returns `[state, setState, changed]` where `state` and `setState` behave\n *          exactly like with the `useState` hook, including guarantees that\n *          `setState` will not change. `change` will be `true` when `value`\n *          changes between renders.\n */\nfunction useUpdatableState<T>(value: T, predicate: StateComparator<T> = defaultComparator): UpdatableResult<T> {\n  // I am explicitly choosing to modify the array returned by useState instead\n  // of spreading its contents into a new array, in case React makes any\n  // guarantees about the array's identity.\n  const stateArray: UpdatableResult<T> = useState(value) as any;\n  const [previousValue, setPreviousValue] = useState(value);\n  const [isChanged, setChanged] = useState(true);\n\n  if (!predicate(value, previousValue)) {\n    setChanged(true);\n    stateArray[1](value);\n    setPreviousValue(value);\n  } else {\n    if (isChanged) {\n      setChanged(false);\n    }\n  }\n  stateArray[2] = isChanged;\n  return stateArray;\n}\n\nexport default useUpdatableState;\n\nconst defaultComparator = <T>(a: T, b: T) => a === b;\n\nexport interface StateComparator<T> {\n  (a: T | undefined, b: T | undefined): boolean;\n}\n\nexport type UpdatableResult<T> = [T, Dispatch<SetStateAction<T>>, boolean];\n"],"names":["useState"],"mappings":";;;;AAEA;;;;;;;;;;;;;;;;;;AAkBA,SAAS,iBAAiB,CAAI,KAAQ,EAAE,SAAiD;IAAjD,0BAAA,EAAA,6BAAiD;;;;IAIvF,IAAM,UAAU,GAAuBA,cAAQ,CAAC,KAAK,CAAQ,CAAC;IACxD,IAAA,KAAoCA,cAAQ,CAAC,KAAK,CAAC,EAAlD,aAAa,QAAA,EAAE,gBAAgB,QAAmB,CAAC;IACpD,IAAA,KAA0BA,cAAQ,CAAC,IAAI,CAAC,EAAvC,SAAS,QAAA,EAAE,UAAU,QAAkB,CAAC;IAE/C,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,aAAa,CAAC,EAAE;QACpC,UAAU,CAAC,IAAI,CAAC,CAAC;QACjB,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QACrB,gBAAgB,CAAC,KAAK,CAAC,CAAC;KACzB;SAAM;QACL,IAAI,SAAS,EAAE;YACb,UAAU,CAAC,KAAK,CAAC,CAAC;SACnB;KACF;IACD,UAAU,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;IAC1B,OAAO,UAAU,CAAC;AACpB,CAAC;AAID,IAAM,iBAAiB,GAAG,UAAI,CAAI,EAAE,CAAI,IAAK,OAAA,CAAC,KAAK,CAAC,GAAA;;;;"}